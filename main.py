# Layers
# Biome Points
# Biome Compositions
# Hill Points
# Altitudes
# Terrain

GENERAL_HEADER = "/* File generated by PythonTerrainSourceGenerator */\n\n"

# Any types defined here should be defined manually in a C# file (i.e. enums)
layers = [
    {
        "name": "biome_points",
        "class_prefix": "BiomePoints",
        "chunk_size": 256,
        "dimensions": 2,
        "point_sparsity": 24,
        "point_data": [ # A new struct will be generated with these fields
            {
                "name": "biome",
                "type": "Biome" # This enum must be defined manually.
            },
            {
                "name": "localX",
                "type": "int"
            },
            {
                "name": "localY",
                "type": "int"
            }
        ]
    },
    {
        "name": "biome_compositions",
        "class_prefix": "BiomeCompositions",
        "chunk_size": 128,
        "dimensions": 2,
        "point_sparsity": 1,
        "dependencies": [
            {
                "name": "biome_points",
                "dependency_range": 64
            }
        ],
        "point_data": {"type": "BiomeComposition"} # This type must be defined manually.
    },
    {
        "name": "hill_points",
        "class_prefix": "HillPoints",
        "dimensions": 2,
        "point_sparsity": 24,
        "dependencies": [
            {
                "name": "biome_compositions",
                "dependency_range": 0
            }
        ]
    },
    {
        "name": "altitudes",
        "class_prefix": "Altitudes",
        "dimensions": 2,
        "point_sparsity": 1,
        "dependencies": [
            {
                "name": "hill_points",
                "dependency_range": 16
            }
        ]
    },
    {
        "name": "terrain",
        "class_prefix": "Terrain",
        "dimensions": 3,
        "point_sparsity": 1,
        "dependencies": [
            {
                "name": "altitudes",
                "dependency_range": 0
            }
        ]
    }
]

# Generate C# Burst code for one layer.
def generate_layer(layer):
    generate_cluster(layer)
    generate_chunk(layer)
    generate_job(layer)

# Generate the job code that generates a chunk (a portion of the world) for a layer.
def generate_job(layer):
    class_name = layer["class_prefix"] + "Job"
    w = CodeWriter(class_name + ".cs")

    # Includes
    w.write("using Unity.Burst;\n")
    w.write("using Unity.Collections;\n")
    w.write("using Unity.Jobs;\n")
    w.write("using Unity.Mathematics;\n")
    w.write("\n")

    # Struct definition
    w.write("[BurstCompile]\n")
    w.write("public struct " + class_name + " : IJob\n")
    w.open_func()

    # Fields
    w.write("public " + layer["class_prefix"] + "Chunk chunkData;\n")
    w.write("[ReadOnly] public int chunkX;\n")
    w.write("[ReadOnly] public int chunkY;\n")
    if (layer["dimensions"] == 3):
        w.write("[ReadOnly] public int chunkZ;\n")
    w.write("[ReadOnly] public int seed;\n")
    w.write("\n")

    # Routine
    w.write("[BurstCompile]\n")
    w.write("public void Execute()\n")
    w.write("{\n")
    w.shift_right()

    # Skip if already generated
    w.write("if (chunkData.isGenerated) return;\n")
    w.write("\n")

    w.close()

# Generate the struct for a single point in a layer.
def generate_point(layer):
    class_name = layer["class_prefix"] + "Point"
    w = CodeWriter(class_name + ".cs")
    w.close()


# Generate the chunk struct for a layer (stores data for a portion of the world).
def generate_chunk(layer):
    class_name = layer["class_prefix"] + "Chunk"
    w = CodeWriter(class_name + ".cs")

    # Includes
    w.write("using Unity.Burst;\n")
    w.write("using Unity.Collections;\n")
    w.write("\n")

    # Struct definition
    w.write("[BurstCompile]\n")
    w.write("public struct " + class_name + "\n")
    w.write("{\n")
    w.shift_right()

    # Fields
    w.write("public NativeList<Biome")

    w.close()

# Generate the cluster struct for a layer (stores all data for the entire world).
def generate_cluster(layer):
    # Calculate some names
    class_name = layer["class_prefix"] + "Cluster"
    chunk_name = layer["class_prefix"] + "Chunk"
    job_name = layer["class_prefix"] + "Job"
    vec_type = "int2"
    if (layer["dimensions"] == 3):
        vec_type = "int3"

    w = CodeWriter(class_name + ".cs")

    # Includes
    w.write("using System;\n")
    w.write("using System.Collections.Generic;\n")
    w.write("using Unity.Burst;\n")
    w.write("using Unity.Collections;\n")
    w.write("using Unity.Jobs;\n")
    w.write("using Unity.Mathematics;\n")
    w.write("using UnityEngine;\n")
    w.write("\n")

    # Struct definition
    w.write("[BurstCompile]\n")
    w.write("public struct " + class_name + "\n")
    w.write("{\n")
    w.shift_right()

    # Fields
    w.write("private NativeHashMap<" + vec_type + ", " + chunk_name + "> chunks;\n")
    w.write("private NativeHashMap<" + vec_type + ", JobHandle> jobs;\n")
    w.write("private int seed;\n")
    w.write("\n")

    # Initialization routine
    w.write("[BurstCompile]\n")
    w.write("public static void Initialize(int seed, out " + class_name + " cluster)\n")
    w.write("{\n")
    w.shift_right()
    w.write("cluster = new " + class_name + "\n")
    w.write("{\n")
    w.shift_right()
    w.write("chunks = new (1000, Allocator.Persistent),\n")
    w.write("jobs = new (1000, Allocator.Persistent),\n")
    w.write("seed = seed\n")
    w.shift_left()
    w.write("};\n")
    w.shift_left()
    w.write("}\n")

    # Did start generating method
    w.write("[BurstCompile]\n")
    w.write("public static bool DidStartGeneratingChunk(ref " + class_name + " cluster, " + vec_type + " chunkPos)\n")
    w.write("{\n")
    w.shift_right()
    w.write("return cluster.chunks.ContainsKey(chunkPos);\n")
    w.shift_left()
    w.write("}\n")
    w.write("\n")

    # Did finish generating method
    w.write("[BurstCompile]\n")
    w.write("public static bool DidFinishGeneratingChunk(ref " + class_name + " cluster, " + vec_type + " chunkPos)\n")
    w.write("{\n")
    w.shift_right()
    w.write("return cluster.chunks.TryGetValue(chunkPos, out " + chunk_name + " chunk) && chunk.isGenerated;\n")
    w.shift_left()
    w.write("}\n")
    w.write("\n")

    # Chunk getter method
    w.write("[BurstCompile]\n")
    w.write("public static " + chunk_name + " GetChunk(ref " + class_name + " cluster, " + vec_type + " chunkPos)\n")
    w.write("{\n")
    w.shift_right()
    w.write("return cluster.chunks[chunkPos];\n");
    w.shift_left()
    w.write("}\n")
    w.write("\n")

    # Chunk setter method
    w.write("[BurstCompile]\n")
    w.write("public static " + chunk_name + " SetChunk(ref " + class_name + " cluster, " + vec_type + " chunkPos, " + chunk_name + " chunk)\n")
    w.write("{\n")
    w.shift_right()
    w.write("cluster.chunks[chunkPos] = chunk;\n");
    w.shift_left()
    w.write("}\n")
    w.write("\n")

    # Chunk generator method
    w.write("[BurstCompile]\n")
    w.write("public static bool GenerateChunk(ref " + class_name + " cluster, " + vec_type + " chunkPos, out JobHandle handle)\n")
    w.write("{\n")
    w.shift_right()
    w.write("if (" + class_name + ".DidStartGeneratingChunk(ref cluster, chunkPos))\n")
    w.write("{\n")
    w.shift_right()
    w.write("handle = new JobHandle {};\n")
    w.write("return false;\n")
    w.shift_left()
    w.write("}\n")
    w.write("\n")

    w.write(chunk_name + ".Initialize(out " + chunk_name + " chunk);\n")
    w.write("cluster.chunks[chunkPos] = chunk;\n")
    w.write(job_name + " job = new " + job_name + "\n")
    w.write("{\n")
    w.shift_right()
    w.write("chunk = chunk,\n")
    w.write("chunkX = chunkPos.x,\n")
    w.write("chunkY = chunkPos.y,\n")
    if (layer["dimensions"] == 3):
        w.write("chunkZ = chunkPos.z,\n")
    w.write("seed = cluster.seed\n")
    w.shift_left()
    w.write("};\n")
    w.write("\n")

    w.write("handle = job.Schedule();\n")
    w.write("cluster.jobs[chunkPos] = handle;\n")
    w.write("return true;\n")
    w.shift_left()
    w.write("}\n")
    w.write("\n")

    # Disposal routine
    w.write("[BurstCompile]\n")
    w.write("public static void Dispose(ref " + class_name + " cluster)\n")
    w.open_func()
    w.write("if (cluster.chunks.Count > 0)\n")
    w.open_func()
    w.write("NativeArray<" + chunk_name + "> chunksToDispose = cluster.chunks.GetValueArray(Allocator.Temp);\n")
    w.write("foreach (" + chunk_name + " chunk in chunksToDispose)\n")
    w.open_func()
    w.write(chunk_name + ".Dispose(chunk);\n")
    w.close_func()
    w.write("chunksToDispose.Dispose();\n")
    w.close_func()
    w.write("cluster.chunks.Dispose();\n")
    w.write("cluster.jobs.Dispose();\n")
    w.close_func()
    w.close_func()

    w.close()

class CodeWriter:
    def __init__(self, file_name):
        self.f = open(file_name, mode='w', encoding='utf-8')
        self.f.write(GENERAL_HEADER)
        self.indent = 0
    
    def write(self, text):
        self.f.write("    " * self.indent)
        self.f.write(text)

    # Add an indent to all future lines
    def shift_right(self):
        self.indent += 1
    
    # Remove an indent from all future lines
    def shift_left(self):
        self.indent -= 1
    
    # Create an opening brace and shift left.
    def open_func(self):
        self.write("{\n")
        self.shift_right()
    
    # Create a closing brace and shift left.
    def close_func(self):
        self.shift_left()
        self.write("}\n\n")
    
    def close(self):
        self.f.close()

# Generate C# Burst code for the entire project (all layers).
def generate_code():
    for layer in layers:
        generate_layer(layer)

if __name__ == "__main__":
    #generate_code()
    generate_layer(layers[0])
