/* File generated by PythonTerrainSourceGenerator */

using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct TerrainJob : IJob
{
    public TerrainChunk chunk;
    [ReadOnly] public NativeArray<BiomeCompositionsChunk> biomeCompositionsChunks;
    [ReadOnly] public NativeArray<AltitudesChunk> altitudesChunks;
    [ReadOnly] public int chunkX;
    [ReadOnly] public int chunkY;
    [ReadOnly] public int chunkZ;
    [ReadOnly] public int seed;
    
    private const int CHUNK_WIDTH = 32;
    private const int BIOME_COMPOSITIONS_CHUNK_RANGE = 0;
    private const int ALTITUDES_CHUNK_RANGE = 0;
    
    [BurstCompile]
    public static void AddBiomeCompositionsChunk(ref TerrainJob job, BiomeCompositionsChunk chunk, in int2 chunkPos)
    {
        job.biomeCompositionsChunks[GetBiomeCompositionsIndex(chunkPos)] = chunk;
    }
    
    [BurstCompile]
    public static int GetBiomeCompositionsIndex(in int2 chunkPos)
    {
        return (chunkPos.x + 0) + ((chunkPos.y + 0) * 1);
    }
    
    [BurstCompile]
    private static void FetchBiomeCompositionsFrom(ref TerrainJob job, ref NativeHashMap<int2, BiomeComposition> localPoints, in int2 offset)
    {
        BiomeCompositionsChunk chunk = job.biomeCompositionsChunks[GetBiomeCompositionsIndex(chunkPos)] = chunk;
        NativeArray<int2> positions = chunk.points.GetKeyArray(Allocator.Temp);
        
        int chunkX = job.chunkX + offset.x;
        int chunkY = job.chunkY + offset.y;
        
        for (int i = 0; i < positions.Length; i++)
        {
            int2 pos = positions[i];
            int2 adjustedPos = new int2(chunkX * CHUNK_WIDTH, chunkY * CHUNK_WIDTH)
            localPoints.Add(adjustedPos, point);
        }
        positions.Dispose();
    }
    
    [BurstCompile]
    public static void AddAltitudesChunk(ref TerrainJob job, AltitudesChunk chunk, in int2 chunkPos)
    {
        job.altitudesChunks[GetAltitudesIndex(chunkPos)] = chunk;
    }
    
    [BurstCompile]
    public static int GetAltitudesIndex(in int2 chunkPos)
    {
        return (chunkPos.x + 0) + ((chunkPos.y + 0) * 1);
    }
    
    [BurstCompile]
    private static void FetchAltitudesFrom(ref TerrainJob job, ref NativeHashMap<int2, int> localPoints, in int2 offset)
    {
        AltitudesChunk chunk = job.altitudesChunks[GetAltitudesIndex(chunkPos)] = chunk;
        NativeArray<int2> positions = chunk.points.GetKeyArray(Allocator.Temp);
        
        int chunkX = job.chunkX + offset.x;
        int chunkY = job.chunkY + offset.y;
        
        for (int i = 0; i < positions.Length; i++)
        {
            int2 pos = positions[i];
            int2 adjustedPos = new int2(chunkX * CHUNK_WIDTH, chunkY * CHUNK_WIDTH)
            localPoints.Add(adjustedPos, point);
        }
        positions.Dispose();
    }
    
    [BurstCompile]
    public void Execute()
    {
        if (chunk.isGenerated.Value) return;
        
        NativeHashMap<int2, BiomeComposition> biomeCompositions = new(100, Allocator.TempJob);
        for (int x = -0; x < 0; x++)
        {
            for (int y = -0; y < 0; y++)
            {
                FetchBiomeCompositionsFrom(ref this, ref biomeCompositions, new int2(x, y));
            }
        }
        
        NativeHashMap<int2, int> altitudes = new(100, Allocator.TempJob);
        for (int x = -0; x < 0; x++)
        {
            for (int y = -0; y < 0; y++)
            {
                FetchAltitudesFrom(ref this, ref altitudes, new int2(x, y));
            }
        }
        
        /* Partial routine - injected into job script by source generator */        
        biomeCompositions.Dispose();
        altitudes.Dispose();
        chunk.isGenerated.Value = true;
    }
}
