/* File generated by PythonTerrainSourceGenerator */

using System;
using System.Collections.Generic;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile]
public struct BiomeCompositionsCluster
{
    [ReadOnly] public BiomePointsCluster biomePointsCluster;
    private NativeHashMap<int2, BiomeCompositionsChunk> chunks;
    private NativeHashMap<int2, JobHandle> jobs;
    private int seed;
    
    private const int CHUNK_WIDTH = 32;
    private const int BIOME_POINTS_CHUNK_RANGE = 2;
    
    [BurstCompile]
    public static void Initialize(int seed, out BiomeCompositionsCluster cluster)
    {
        cluster = new BiomeCompositionsCluster
        {
            chunks = new (1000, Allocator.Persistent),
            jobs = new (1000, Allocator.Persistent),
            seed = seed
        };
    }
    
    [BurstCompile]
    public static bool DidStartGeneratingChunk(ref BiomeCompositionsCluster cluster, int2 chunkPos)
    {
        return cluster.chunks.ContainsKey(chunkPos);
    }
    
    [BurstCompile]
    public static bool DidFinishGeneratingChunk(ref BiomeCompositionsCluster cluster, int2 chunkPos)
    {
        return cluster.chunks.TryGetValue(chunkPos, out BiomeCompositionsChunk chunk) && chunk.isGenerated;
    }
    
    [BurstCompile]
    public static BiomeCompositionsChunk GetChunk(ref BiomeCompositionsCluster cluster, int2 chunkPos)
    {
        return cluster.chunks[chunkPos];
    }
    
    [BurstCompile]
    public static BiomeCompositionsChunk SetChunk(ref BiomeCompositionsCluster cluster, int2 chunkPos, BiomeCompositionsChunk chunk)
    {
        cluster.chunks[chunkPos] = chunk;
    }
    
    [BurstCompile]
    public static bool GenerateChunk(ref BiomeCompositionsCluster cluster, int2 chunkPos, out JobHandle handle)
    {
        if (BiomeCompositionsCluster.DidStartGeneratingChunk(ref cluster, chunkPos))
        {
            handle = new JobHandle {};
            return false;
        }
        
        BiomeCompositionsChunk.Initialize(out BiomeCompositionsChunk chunk);
        cluster.chunks[chunkPos] = chunk;
        BiomeCompositionsJob job = new BiomeCompositionsJob
        {
            chunk = chunk,
            biomePointsChunks = new NativeArray<BiomePointsChunk>(25, Allocator.Persistent);
            chunkX = chunkPos.x,
            chunkY = chunkPos.y,
            seed = cluster.seed
        }
        
        NativeList<JobHandle> handles = new NativeList(20, Allocator.Persistent);
        for (int x = -2; x <= 2; x++)
        {
            for (int y = -2; y <= 2; y++)
            {
                int globalX = chunkPos.x + x;
                int globalY = chunkPos.y + y;
                int2 globalPos = new int2(globalX, globalY);
                
                if (BiomePointsCluster.GenerateChunk(ref biomePointsCluster, globalPos, out JobHandle handle))
                {
                    handles.Add(handle);
                }
                job.biomePointsChunks[BiomeCompositionsJob.GetBiomePointsIndex(globalPos)] = 
                    BiomePointsCluster.GetChunk(ref biomePointsCluster, globalPos);
            }
        }
        handle = job.Schedule(handles);
        handles.Dispose();
        cluster.jobs[chunkPos] = handle;
        return true;
    }
    
    [BurstCompile]
    public static void Dispose(ref BiomeCompositionsCluster cluster)
    {
        if (cluster.chunks.Count > 0)
        {
            NativeArray<BiomePointsChunk> chunksToDispose = cluster.chunks.GetValueArray(Allocator.Temp);
            foreach (BiomePointsChunk chunk in chunksToDispose)
            {
                BiomePointsChunk.Dispose(chunk);
            }
            chunksToDispose.Dispose();
        }
        cluster.chunks.Dispose();
        cluster.jobs.Dispose();
    }
}
