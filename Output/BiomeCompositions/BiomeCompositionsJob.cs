/* File generated by PythonTerrainSourceGenerator */

using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct BiomeCompositionsJob : IJob
{
    public BiomeCompositionsChunk chunk;
    [ReadOnly] public NativeArray<BiomePointsChunk> biomePointsChunks;
    [ReadOnly] public int chunkX;
    [ReadOnly] public int chunkY;
    [ReadOnly] public int seed;
    
    private const int CHUNK_WIDTH = 32;
    private const int BIOME_POINTS_CHUNK_RANGE = 2;
    
    [BurstCompile]
    public static void AddBiomePointsChunk(ref BiomeCompositionsJob job, BiomePointsChunk chunk, in int2 chunkPos)
    {
        job.biomePointsChunks[GetBiomePointsIndex(chunkPos)] = chunk;
    }
    
    [BurstCompile]
    public static int GetBiomePointsIndex(in int2 chunkPos)
    {
        return (chunkPos.x + 2) + ((chunkPos.y + 2) * 5);
    }
    
    [BurstCompile]
    private static void FetchBiomePointsFrom(ref BiomeCompositionsJob job, ref NativeHashMap<int2, Biome> localPoints, in int2 offset)
    {
        BiomePointsChunk chunk = job.biomePointsChunks[GetBiomePointsIndex(chunkPos)] = chunk;
        NativeArray<int2> positions = chunk.points.GetKeyArray(Allocator.TempJob);
        
        int chunkX = job.chunkX + offset.x;
        int chunkY = job.chunkY + offset.y;
        
        for (int i = 0; i < positions.Length; i++)
        {
            int2 pos = positions[i];
            int2 adjustedPos = new int2(chunkX * CHUNK_WIDTH, chunkY * CHUNK_WIDTH)
            localPoints.Add(adjustedPos, point);
        }
        positions.Dispose();
    }
    
    [BurstCompile]
    public void Execute()
    {
        if (chunk.isGenerated.Value) return;
        
        NativeHashMap<int2, Biome> biomePoints = new(100, Allocator.TempJob);
        for (int x = -2; x <= 2; x++)
        {
            for (int y = -2; y <= 2; y++)
            {
                FetchBiomePointsFrom(ref this, ref biomePoints, new int2(x, y));
            }
        }
        
        /* Partial routine - injected into job script by source generator */
        
        NativeArray<int2> biomePointPositions = biomePoints.GetKeyArray(Allocator.Temp);
        
        // Calculate biome compositions for all tiles in the biome chunk
        for (int localX = 0; localX < CHUNK_WIDTH; localX++)
        {
            for (int localY = 0; localY < CHUNK_WIDTH; localY++)
            {
                BiomeComposition comp = new BiomeComposition
                {
                    biomeCount = 0
                };
                foreach (int2 biomePointPos in biomePointPositions)
                {
                    float distSquared = math.distancesq(new int2(localX, localY), biomePointPos);
                    if (distSquared > ClusterChunkSettings.BIOME_POINT_INFLUENCE_RADIUS * ClusterChunkSettings.BIOME_POINT_INFLUENCE_RADIUS)
                    {
                        continue;
                    }
        
                    // Influence is the reciprocal square root of squared distance,
                    // which is the reciprocal of the distance.
                    float influence = math.rsqrt(distSquared);
        
                    Biome biome = biomePoints[biomePointPos];
                    BiomeComposition.AddBiome(ref comp, biome, influence);
                }
                BiomeComposition.Normalize(ref comp);
                BiomeCompositionChunk.SetComposition(ref chunk, localX, localY, comp);
            }
        }
        
        biomePointPositions.Dispose();
        
        biomePoints.Dispose();
        biomePointsChunks.Dispose();
        
        chunk.isGenerated.Value = true;
    }
}
